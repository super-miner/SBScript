# SBScript Design Specifications

> [!Note]
>
> This document contains not only design specifications for the language and its syntax, but also the compiler and standard library. This will be corrected at a later date.

SBScript (SBS) aims to create a language that compiles to highly efficient Scratch (`.sb3`) projects, while remaining decoupled from the underlying structure of Scratch. This is as opposed to other languages, which try to emulate the structure of Scratch projects in text (see [goboscript](https://github.com/aspizu/goboscript)). The language will have a similar syntax and feature set to modern programming languages such as C# and Swift with minimal sacrifices to convinience and ease of use. As a result, SBS will lose some performance by implementing features not found natively in Scratch and the produced Scratch projects may be less readable, but this is deemed worth it in exchange for these conviniences.

## Scratch 3's Limitations

Before discussing the design of SBS it is important to define some of Scratch's limitations. In case these limitations are changed in the future, their values will only be outlined in this section of the document.

Only the relevant limitations will be listed here, you can find a full list on the [Limitations of Scratch](https://awesome-llama.github.io/articles/limitations-of-scratch) website.

> JSON Size Limit → 5MB:
>
> The size limit for the `project.json` file.
> Only applies to online projects, although from testing the desktop editor seems to be unstable with large files.

> Asset Size Limit → 1MB:
> 
> The size limit for each *individual* asset inside of a project.
> (The [wiki](https://en.scratch-wiki.info/wiki/Project_File_Size) lists no official limit on how many assets a project can contain).

> List Size Limit → 200,000 items:
>
> The maximum number of items a list can hold.

Scratch is also limited by its processing speed largely as a result of it being an interpreted language and most of its rendering functionality being bound to the CPU. This is the most prominant limitation and will be the biggest factor when deciding how projects generated by the compiler should function. 

## Unofficial (Hacked) Blocks

Scratch 3 has a few unofficial blocks (commonly referred to as "hacked" blocks) that cannot be obtained through the official scratch editor. These blocks are still a part of Scratch and will work properly if you are able to get them into your project. Getting these blocks usually just requires using a specific opcode, but there are a few that use other techniques.

### Hiding Blocks

Sometimes unofficial blocks will cause a project to break when loaded into scratch, hiding/deleting all of the blocks in a given sprite. For example, setting the variable parameter in `[set [variable] to ()]` to a list will cause this issue ([source](https://scratch.mit.edu/projects/1048874723)). This is usually a rendering issue, rather than an issue with the block itself. To get around this we can hide the block. To hide a block you can put it in a function and then and then set `"shadow": true` for the function definition block.

> [!Note]
> 
> Unofficial blocks where the only change is to the opcode usually do not cause this rendering issue and thus do not need to be hidden.

### Unofficial Blocks in SBScript

According to [the Scratch Wiki](https://www.en.scratch-wiki.info/wiki/Hidden_Blocks) using unofficial blocks may cause your project's visibility to be [limited](https://www.en.scratch-wiki.info/wiki/NFE). Unofficial blocks also may not be supported in future versions of Scratch. Because of this the SBS compiler will need to let the user control whether or not the generated project will contain any unofficial blocks.

## The Compiler

### Variables and Memory

A naive approach to implementing variables in the compiled scratch project might look like this:

```CSharp
scratch_variable_name = variable_scope_as_string + variable_name

// Example results:
//
// programVersion
// coolFunc.x
// doMath.1.1.3.temp
```

But this has a few limitations that will need to be addressed, notably:
- List size limits
- No support for nested data types (i.e. lists of numbers, multi dimentional lists, lists of objects containing other lists)

#### List types

Lists can — for the most part — be handled using the same ideas as variables, the only issue is their size limit. To get around this we have a few options depending on the circumstances.

If we know the size of the list at compile time then there are one of two options: 

**A.** The list size is smaller than Scratch's limit and we can treat it like any other variable.

**B.** The list is larger then Scratch's limit, in which case we can use multiple lists and apply this naming convension:

```CSharp
scratch_list_name = list_scope_as_string + list_name + list_block_number

// Example results:
//
// undoHistory.3
// sortUsers.newList.0
// simulateStep.2.5.ignoreList.1
```

Unfortunately, Scratch does not let you dynamically select a list to access, so helper functions will have to be created:

```CSharp
[guestList.getItem (index)]
  // Binary search will be used in these functions to increase efficiency.
  [if (index > 400000)]
    [if (index > 600000)]
      [set [returnValue] to (get item (index - 600000) from [guestList.3])]
    [else]
      [set [returnValue] to (get item (index - 400000) from [guestList.2])]
  [else]
    [if (index > 200000)]
      [set [returnValue] to (get item (index - 200000) from [guestList.1])]
    [else]
      [set [returnValue] to (get item (index) from [guestList.0])]
```

In certain circumstances the compiler may be able to do some clever optimisations to save having to traverse this binary tree.

```CSharp
int[262144] unitsValues;

for (int i in 0...262144) {
  unitsValues[i] = 100;
}

// >>> COMPILES TO >>>

[set [1.i] to (0)]
[repeat (200000) times]
  [replace item (1.i) of [unitsValues.0] with (100)]
  [change [1.i] by (1)]
[set [1.i] to (0)]
[repeat (62144) times]
  [replace item (1.i) of [unitsValues.1] with (100)]
  [change [1.i] by (1)]
```

## The Language

### Variables

Variables in SBS will be typed, this is mostly to enforce good practices rather than for any technical reason as in Scratch variables are not typed. 

```CSharp
// An example variable definition.

int myVar = 10;
```

### Collections

Due to the limit Scratch places on the sizes of lists, all collections will need to be initilized with a maximum upper bound on how many elements they can hold. Keep in mind that this does not mean that all collections will have a fixed size or take up a fixed amount of memory, but is only an *upper* bound on their size. One Scratch list will need to be created per every 200,000 items so the size an empty collection of size $n$ will take up is $\frac{n}{200000}\times s$ where $s$ is the size of an empty Scratch list.

```CSharp
// An example list definition.

List<int>[400000] myList = [];


// An example dictionary definition.

Dictionary<string, int>[575000] myDict = {};
```



## The Standard Library

Although the standard library is not a part of the language itself, but it defines some important conventions for how the compiled projects should look. Because of this it is deemed important to include information about it here.
