# SBScript Design Specifications

SBScript (SBS) aims to create a language that compiles to highly efficient Scratch (`.sb3`) projects, while remaining decoupled from the underlying structure of Scratch. This is as opposed to other languages, which try to emulate the structure of Scratch projects in text (see [goboscript](https://github.com/aspizu/goboscript)). The language will have a similar syntax and feature set to modern programming languages such as C# and Swift with minimal sacrifices to convinience and ease of use. As a result, SBS will lose some performance by implementing features not found natively in Scratch and the produced Scratch projects may be less readable, but this is deemed worth it in exchange for these conviniences.

## Scratch 3's Limitations

Before discussing the design of SBS it is important to define some of Scratch's limitations. In case these limitations are changed in the future, their values will only be outlined in this section of the document.

> JSON Size Limit → 5MB:
>
> The size limit for the `project.json` file.
> Only applies to online projects, although from testing the desktop editor seems to be unstable with large files.

> Asset Size Limit → 1MB:
> 
> The size limit for each *individual* asset inside of a project.
> (The [wiki](https://en.scratch-wiki.info/wiki/Project_File_Size) lists no official limit on how many assets a project can contain).

> List Size Limit → 200,000 items:
>
> The maximum number of items a list can hold.

> Variable Size Limit → 10,240 characters:
>
> The maximum amount of characters a given variable **or list entry** can store.

Scratch is also limited by its processing speed largely as a result of it being an interpreted language and most of its rendering functionality being bound to the CPU. This is the most prominant limitation and will be the biggest factor when deciding how projects generated by the compiler should function. 

## The Language

### Variables and Memory

A naive approach to implementing variables in the compiled scratch project might look like this:

```CSharp
scratch_variable_name = variable_scope_as_string + variable_name

// Example results:
//
// programVersion
// coolFunc.x
// doMath.1.1.3.temp
```

But this has a few limitations that will need to be addressed, notably:
- List size limits
- No support for nested data types (i.e. lists of numbers, multi dimentional lists, lists of objects containing other lists)

#### List types

Scratch lists can (for the most part) be handled using the same ideas as variables, the only issue is their size limit. Lists in Scratch can only store so many items, meaning we'll have to get creative.

If we know the size of the list at compile time and it is larger than the size of a single list we can use multiple lists:

```CSharp
scratch_list_name = list_scope_as_string + list_name + list_block_number

// Example results:
//
// undoHistory.3
// sortUsers.newList.0
// simulateStep.2.5.ignoreList.1
```

Unfortunately scratch does not let you dynamically select a list to access, so helper functions will have to be created:

```CSharp
[guestList.getItem (index)]
  [if (index > 400000)]
    [if (index > 600000)]
      [set [guestList.getItem.output] to (get item (index - 600000) from [guestList.3])]
    [else]
      [set [guestList.getItem.output] to (get item (index - 400000) from [guestList.2])]
  [else]
    [if (index > 200000)]
      [set [guestList.getItem.output] to (get item (index - 200000) from [guestList.1])]
    [else]
      [set [guestList.getItem.output] to (get item (index) from [guestList.0])]
```

## The Standard Library

Although the standard library is not a part of the language itself, but it defines some important conventions for how the compiled projects should look. Because of this it is deemed important to include information about it here.

### The Generated Project

Due to the design goal of decoupling the structure of the language from the structure of the generated project some details of the project will have to be constrained. These constraints will be chosen mainly based on runtime speed, but occasionally based on space efficiency as well.


