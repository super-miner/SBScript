# SBScript Design Specifications

SBScript (SBS) aims to create a language that compiles to highly efficient Scratch (`.sb3`) projects, while remaining decoupled from the underlying structure of Scratch. This is as opposed to other languages, which try to emulate the structure of Scratch projects in text (see [goboscript](https://github.com/aspizu/goboscript)). The language will have a similar syntax and feature set to modern programming languages such as C# and Swift with minimal sacrifices to convinience and ease of use. As a result, SBS will lose some performance by implementing features not found natively in Scratch and the produced Scratch projects may be less readable, but this is deemed worth it in exchange for these conviniences.

## Scratch 3's Limitations

Before discussing the design of SBS it is important to define some of Scratch's limitations. In case these limitations are changed in the future, their values will only be outlined in this section of the document.

> JSON Size Limit → 5MB:
>
> The size limit for the `project.json` file.
> Only applies to online projects, although from testing the desktop editor seems to be unstable with large files.

> Asset Size Limit → 1MB:
> 
> The size limit for each *individual* asset inside of a project.
> (The [wiki](https://en.scratch-wiki.info/wiki/Project_File_Size) lists no official limit on how many assets a project can contain).

> List Size Limit → 200,000 items:
>
> The maximum number of items a list can hold.

> Variable Size Limit → 10,240 characters:
>
> The maximum amount of characters a given variable **or list entry** can store.

Scratch is also limited by its processing speed largely as a result of it being an interpreted language and most of its rendering functionality being bound to the CPU. This is the most prominant limitation and will be the biggest factor when deciding how projects generated by the compiler should function. 

## The Generated Project

### Variables and Memory

A naive approach to implementing variables in the compiled scratch project might look like this:

```CSharp
scratch_variable_name = variable_scope_as_string + variable_name

// Example results:
//
// programVersion
// coolFunc.x
// doMath.1.1.3.temp
```

But this has a few limitations that will need to be addressed, notably:
- List size limits
- No support for nested data types (i.e. lists of numbers, multi dimentional lists, lists of objects containing other lists)

#### List types

Lists can — for the most part — be handled using the same ideas as variables, the only issue is their size limit. To get around this we have a few options depending on the circumstances.

If we know the size of the list at compile time then there are one of two options: 

**A.** The list size is smaller than Scratch's limit and we can treat it like any other variable.

**B.** The list is larger then Scratch's limit, in which case we can use multiple lists and apply this naming convension:

```CSharp
scratch_list_name = list_scope_as_string + list_name + list_block_number

// Example results:
//
// undoHistory.3
// sortUsers.newList.0
// simulateStep.2.5.ignoreList.1
```

Unfortunately, Scratch does not let you dynamically select a list to access, so helper functions will have to be created:

```CSharp
[guestList.getItem (index)]
  // Binary search will be used in these functions to increase efficiency.
  [if (index > 400000)]
    [if (index > 600000)]
      [set [returnValue] to (get item (index - 600000) from [guestList.3])]
    [else]
      [set [returnValue] to (get item (index - 400000) from [guestList.2])]
  [else]
    [if (index > 200000)]
      [set [returnValue] to (get item (index - 200000) from [guestList.1])]
    [else]
      [set [returnValue] to (get item (index) from [guestList.0])]
```

In certain circumstances the compiler may be able to do some clever optimisations to save having to traverse this binary tree.

```CSharp
int[262144] unitsValues;

for (int i in 0...262144) {
  unitsValues[i] = 100;
}

// >>> COMPILES TO >>>

[set [1.i] to (0)]
[repeat (200000) times]
  [replace item (1.i) of [unitsValues.0] with (100)]
  [change [1.i] by (1)]
[set [1.i] to (0)]
[repeat (62144) times]
  [replace item (1.i) of [unitsValues.1] with (100)]
  [change [1.i] by (1)]
```

## The Language

### Variables

Variables in SBS will be typed. Unlike C# there will be no `new` keyword as the compiler will decide whether a variable needs to be placed dynamically in memory (see *Variables and Memory*).

```CSharp
// An example variable definition.

int myVar = 10;
```

### Lists and Arrays

Due to the different ways of handling lists that stem from the limitations outlined in *Variables and Memory* there will be three types of lists/arrays included as part of the language.

#### Arrays

Arrays are fixed size sequences that can not have elements added or removed from them.

```CSharp
// Some examples of array definitions.

// Creates an array with a fixed size. The Scratch list will be populated with 0s at compile time.
int[500000] aBigArray;
int[500000] aBigArray2 = [];

// Creates an array with a fixed size. The remaining values of the Scratch list will be populated with 0s at compile time.
string[100000] names = ['Bob', 'Joe', 'Jean'];

// Creates an array with a fixed size. The Scratch list will contain the values provided.
num[5] shortListNums = [1.2, 88.1, 94.7, 12.3, 9.9];
```

#### Bounded Lists

Bounded Lists are sequences that can have elements added or removed from them, but have an upper bound to how many elements they can contain.

```CSharp
// Some examples of BoundedList definitions.

// Creates a BoundedList with no items in it.
BoundedList<num> fovouriteNumbers = (maxSize: 100);

// Creates a BoundedList with some items in it.
BoundedList<string> accountHolders = ('Geoff', 'Gordon', 'Grant', 'Gertrude', maxSize: 250);
BoundedList<int> validIds = (maxSize: 5, 100, 101);
```

#### Lists

Lists are sequences that can have elements added or removed from them, and do not have an upper bound.

```CSharp
// Some examples of List definitions.

// Creates a List with no items in it.
List<int> fileIds = ();

// Creates a BoundedList with some items in it.
List<string> operatingSystems = ('Windows', 'Linux', 'MacOS');
```

## The Standard Library

Although the standard library is not a part of the language itself, but it defines some important conventions for how the compiled projects should look. Because of this it is deemed important to include information about it here.
